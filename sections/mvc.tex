\frame{\frametitle{Separazione Modello-Vista}
  %inserire UML evidenziando separazione modello vista
}

\subsection{Rimozione \texttt{toString()} dalle classi di dominio}
\begin{frame}[fragile]
  \frametitle{Situazione pre-refactor}
  \begin{lstlisting}[autogobble, title={\texttt{toString()} di \texttt{Article.java}}]
  @Override
  public String toString() {
      StringBuilder sb = new StringBuilder();
      sb.append(/* Articolo con ID, categoria, stato... */);
      for (Map.Entry<String, String> field:
            fields.entrySet()) {
          sb.append(/* Campo con chiave, valore */);
      }
      return sb.toString();
  }
  \end{lstlisting}

  \begin{itemize}
    \item Il \emph{Model} dipende dalla \emph{View}
    \begin{itemize}
      \item Il \emph{Model} non è riusabile (presuppone una CLI come \emph{View})
      \item Viola \textbf{Open-Closed Principle}
      \item Viola \textbf{Single Responsibility Principle}
    \end{itemize}
    \item \texttt{toString()} dovrebbe essere usato a scopo di \emph{debug}, non per l'interfaccia
  \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Soluzione con Chain of Responsibility}
    \begin{enumerate}
        \item Definire una \emph{Chain of Responsibility} responsabile della conversione degli oggetti
        di dominio nelle loro rappresentazioni testuali.
        \item Creare un'associazione dalla \emph{view} astratta alla \emph{Chain of Responsibility}.
        \item Fornire tramite la \emph{view} astratta un metodo \texttt{render(...)}.
    \end{enumerate}

    \begin{figure}
        \includegraphics[width=0.8\textwidth]{img/chain.png}
    \end{figure}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uso}
  \begin{lstlisting}[autogobble, title={\texttt{AbstractView.java}}]
   private final AbstractRenderer chain = new ArticleRenderer(
                                 new CategoryRenderer(
                                 new ConfigRenderer(
                                 new ExchangeRenderer(
                                 new DefaultRenderer(null)))));

   protected String render(Object o) {
        return chain.render(o);
   }

   protected <T> String renderAll(Collection<T> collection) {
        return collection.stream().map(this::render)
                         .collect(Collectors.joining("\n"));
   }
  \end{lstlisting}
    \begin{itemize}
        \item \texttt{render(...)} è a disposizione delle \emph{View} concrete.
        \item \texttt{DefaultRenderer} fa da renderer \emph{catch-all}
        attraverso il \texttt{toString()} di \texttt{Object}.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Miglioramento con Set Of Responsibility}

    \begin{figure}
        \includegraphics[width=0.7\textwidth]{img/setofresponsibility.png}
    \end{figure}
    \begin{itemize}
      \item Nessun renderer è ``più uguale degli altri''.
      \item Il caso \emph{catch-all} è definito dal creatore del set di renderer.
      \item La responsabilità di creare il set è di \texttt{SetRenderer}.
    \end{itemize}
\end{frame}


\subsection{Estrazione dei Controller MVC dalle classi di presentazione}
\frame{\frametitle{MV $\to$ MVC}
precedente struttura M-V, controller erano GRASP, mentre ora estratti controller MVC  dalle view,
e fatti dialogare con controller GRASP (completa separazione MVC)
%inserire UML delle classi per mostrare differenza
}