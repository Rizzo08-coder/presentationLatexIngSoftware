\subsection{White-box}
\beamertitle
 \begin{frame} [fragile]
     \frametitle{Codice}
     \begin{lstlisting}[autogobble, title={\texttt{Category.java}}]
        public Category searchTree(Strign catName) {
            if (this.name.equalsIgnoreCase(catName)) return this;
            for (Category child : children.values()) {
                Category lookup = child.searchTree(catName);
                if (lookup != null) return lookup;
            }
            return null;
        }
     \end{lstlisting}
     \begin{itemize}
         \item Metodo che abbiamo deciso di testare siccome é fondamentale per la logica di business
         \item Contiene una ricorsione, quindi facile generare bug
         \item Utilizzato testing per cammini indipendenti:
           \begin{itemize}
               \item Determinati cammini indipendenti dopo aver costruito flow graph
               \item Fatti test per ogni cammino indipendente e ulteriori test aggiuntivi
           \end{itemize}
     \end{itemize}
 \end{frame}

 \begin{frame}
     \frametitle{Flow Graph}
     \begin{figure}
         \includegraphics[width=0.9\textwidth]{img/flowGraphSearchTree.png}
     \end{figure}
 \end{frame}

\begin{frame}
    \frametitle{Complessitá Ciclomatica}
    La complessitá ciclomatica puó essere calcolata:
    \begin{enumerate}
        \item Contando le regioni, ovvero $4$
        \item $12-10+2=4$, archi e nodi
        \item $3+1=4$, nodi predicato
    \end{enumerate}
    Dalla figura la complessitá ciclomatica é pari a 4

    \\
    Cammini indipendenti:
    \begin{itemize}
        \item $1-9-10$
        \item $1-2-3-7-10$
        \item $1-2-3-4-5-8-10$
        \item $1-2-3-4-5-6-3-7-10$
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Casi di Test}
    \begin{figure}
        \includegraphics[width=0.8\textwidth]{img/casiTestWhiteBox.png}
    \end{figure}
    \begin{itemize}
        \item Testing per cammini indipendenti: $1-2-3-4$
        \item Testing per cicli: $2-7-8$ \\
            2 $\to$ n=0, 7 $\to $n=1, 8 $\to$ n=2
        \item Test aggiuntivi: $5-6$
    \end{itemize}
\end{frame}

\begin{frame} [fragile]
    \frametitle{Codice}
    \begin{lstlisting}[autogobble, title={\texttt{CategoryTest.java}}]
     @Test
     void searchTreeSuccessWithNoChildAndSameCategoryName() {
        Category category = new Category(
                "name",
                "description",
                Collections.emptyMap()
        );
        assertEquals(category, category.searchTree("name"));
     }
    \end{lstlisting}
    \begin{itemize}
        \item Con questo codice testato il caso $1-9-10$
    \end{itemize}
\end{frame}

\subsection{Black-box}
\beamertitle
\begin{frame}
    \frametitle{Black-Box}
    Per il testing Black-Box abbiamo verificato gli scenari principali dei casi d'uso
    piú rilevanti.
    In particolare ci é servito per fare regression testing durante l'estrazione
    degli MVC Controller.
    \\
    Per facilitare il testing abbiamo applicato Dependency Inversion, grazie al quale
    abbiamo potuto implementare degli oggetti fittizi (Mock):
    \begin{itemize}
        \item \emph{InMemoryDataContainer}: contenitore dei dati senza persistenza
        \item \emph{QueueInputProvider}: provider di input non interattivo basato su code
        \item \emph{Clock.fixed}: ora costante per testing
    \end{itemize}
\end{frame}

\begin{frame} [fragile]
    \frametitle{codice}
    \begin{lstlisting}[autogobble, title={\texttt{QueueInputProvider.java}}]
     private Queue<Integer> integerInputs;

     public void setIntegerInputs(Collection<Integer> integerInputs) {
        this.integerInputs = new LinkedList<>(integerInputs);
    }

     @Override
     public int leggiIntero(...) {
        return integerInputs.remove();
     }
    \end{lstlisting}
    \begin{lstlisting}[autogobble, title={\texttt{ArticleMVControllerTest.java}}]
    @Test
    void editArticle() {
      insertArticle();
      queueInputProvider.setIntegerInputs(List.of(4, 1, 1, 0));
      queueInputProvider.setBooleanInputs(List.of(true));
      articleMVController.execute(...);
      assertThat(out.toString(), containsString(...));
    }
    \end{lstlisting}
\end{frame}
